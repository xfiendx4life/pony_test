# Тестовое задание для Pony labs
 
## Написать приложение на Go, которое:
### подключается к MQTT-брокеру ✅

Подключение реализовано в пакете [process](./pkg/process/process.go)

- Обновляет/создает в оперативке объект, записывает в текстовый файл 
        
Объект представляет структуру, описанную в пакете [models](./pkg/models/models.go)
```go
type Message struct {
ID        string `json:"id"`
Data      string `json:"message"`
TimeStamp time.Time
}
```
Запись в текcnовый файл осуществляется в пакете [storage](./pkg/message/storage/filesystem.go)

Объект, через который мы производим запись в текстовый файл реализует интерфейс `Storage`, так что при желании можно нарастить функционал и заменить.
```go
type Storage interface {
	Write(ctx context.Context, message models.Message) error
}
```
__Пример записанного сообщения:__
```sh
2022/06/30-09:45:45: FrmCtr008 - {"t_air":0,"h_air":0,"co2":0,"time":35123,"read_errs":0,"outs_state":0,"uptime":546601,"wifi":-63}
```
## Слушает порт и реализует API:
[API описано в формате openapi](./api/api.yml) и реализовано:
* хэндлеры описаны в пакете [deliver](./pkg/message/deliver/)
* сервер - в пакете [rest](./pkg/rest/rest.go)

## Не реализовано:
* обработка ответа на `rpc-запрос` от сервера (я не смог его получить - не рискнул обрабатывать без примера)
* веб-интерфейс (не хватило времени)

## Запуск приложения:

Для запуска приложения можно использовать команду `make run`. Приложение запустится на `localhost:8080`, если хочется изменить порт или хост, то можно измениь переменные в [Makefile](./Makefile). 

__Запуск вручную:__
```sh
HOST=localhost PORT=8080 go run ./cmd/pony/main.go
```
тестирование - `make test`

## ИТОГ:
Приложение реализовано как монолит, обработки входящих сообщений и rest-сервер запускаются в отдельных горутинах. 
В качестве общей памяти используется структура `sync.Map`, для передачи в сторону rpc сообщения использовал небольшой костыль - приводил сообщение к типу  `models.Message`, потом обратно. Нужно конечно будет поменять на канал.

